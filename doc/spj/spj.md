<h1 style="display: flex; justify-content: center">SPJ算法实验报告</h1>

[TOC]

# 1. 实验分工安排

周强俊：Indexscan、投影操作算法、报告撰写

唐雨馨：Tablescan、投影操作算法、嵌套循环连接、基于排序的等值连接、基于索引的连接、报告撰写

周智淦：嵌套循环连接、基于散列的连接操作算法、报告撰写

字阳：测试方案设计、报告撰写

# 2.系统环境

系统：Ubuntu-24.04

clang版本：18.1.3

glibc版本：2.39

cmake版本：3.28.3

# 3. 实验设计与实现

## 3.1 查询处理器概述

查询处理器是数据库系统中负责数据查询和操作的核心模块。本系统采用**迭代器模型**，每个查询操作被抽象为一个算子（executor），通过调用其核心接口 `Next()` 来逐元组地获取结果。查询管理器支持一系列算子，包括：

- 数据操作算子（如插入、更新、删除）
- 扫描算子（如表扫描 `TableScan` 和索引扫描 `IndexScan`）
- 连接算子（如嵌套循环连接、基于排序的等值连接、基于散列的等值连接和基于索引的连接）

## 3.2 序列扫描（SeqScan）

### 3.2.1 SeqScan 的功能

SeqScanExecutor 实现了基于顺序扫描的查询操作，其主要功能包括：

- 遍历表中的所有记录，逐条扫描。
- 根据提供的条件过滤数据，返回满足条件的记录。
- 支持多条件的逻辑组合与查询。
- 确保结果符合用户定义的查询谓词（predicate）。

### 3.2.2 设计思路

1. 表和条件的初始化

`SeqScanExecutor` 的构造函数中完成了表元数据与扫描条件的初始化：

- **表元信息加载**：通过 `sm_manager_` 获取目标表的元数据，包括表的字段、模式（Schema）、字段偏移等。
- **条件加载**：将用户传入的查询条件 (`conds`) 存储在内部变量中，并支持子查询条件的延迟解析。

2. 扫描器初始化

`beginTuple()` 是扫描的入口点，主要完成以下操作：

- **初始化扫描器**：通过 `RmScan` 创建表的记录扫描器，用于顺序遍历表中的记录。
- **跳过不符合条件的记录**：调用 `predicate()` 判断记录是否满足查询条件，对不满足的记录调用 `scan_->Next()` 跳过，直至找到第一条符合条件的记录。

3. 记录遍历

`nextTuple()` 函数用于遍历记录：

- 每次调用时，通过 `scan_->Next()` 获取下一条记录。
- 调用 `predicate()` 对记录进行过滤，跳过不符合条件的记录，直到遍历结束。

4. 条件过滤

`predicate()` 函数用于检查当前记录是否满足查询条件：

- **支持多条件组合**：逐一遍历条件列表，所有条件均满足时返回 `true`，否则返回 `false`。
- **值比较**：从当前记录中提取条件字段的值，并与条件值进行比较，根据条件操作符（如 `=`、`>` 等）判断是否满足。

### 3.2.3 设计特点

1. **灵活的条件支持**
   - 支持简单的条件过滤，如字段值比较（=、>、< 等）。
   - 支持子查询条件（如 `IN`、`=` 等），并在运行时动态解析子查询结果。
2. **高效的顺序扫描**
   - 使用 `RmScan` 遍历表中的所有记录，避免不必要的复杂操作。
   - 在扫描过程中即时过滤记录，减少不必要的存储访问。

-------

## 3.3 索引扫描（IndexScan）

### 3.3.1 IndexScan 的功能

`IndexScanExecutor` 是实现基于索引的扫描算子，其主要功能包括：

- 利用索引快速定位满足条件的记录范围。
- 高效执行单点查询和范围查询。
- 支持多列索引的条件解析。
- 确保扫描结果满足查询条件。

### 3.3.2 设计思路

1. 条件解析与范围确定

`IndexScanExecutor` 的 `beginTuple()` 函数是索引扫描的入口点，首先确定索引扫描的上下界范围：

- **索引信息加载**：通过 `sm_manager_` 获取当前表和字段的索引元信息，以及对应的 `IndexHandle`。
- **初始化键缓冲区**：根据索引字段总长度初始化两个缓冲区 `key_lower` 和 `key_upper`，分别表示索引扫描的下界和上界。
- **预计算列偏移与长度**：对于多列索引，系统预先计算每列的偏移和长度，便于后续快速构造键值。

2. 条件解析与键值映射

针对查询条件（如 `OP_EQ`、`OP_GT` 等），通过以下逻辑构造索引扫描的范围：

- **等值条件** (`OP_EQ`)：将条件值填充到 `key_lower` 和 `key_upper`，通过索引的 `LowerBound` 和 `UpperBound` 获取范围。
- **范围条件**（如 `OP_GE`、`OP_LE`）：根据条件类型构造单侧边界。
- **多列索引支持**：对于多列索引，逐列解析条件并修改相应的键值偏移。

3. 初始化扫描器

利用解析后的上下界范围，初始化 `IxScan` 对象：

- `IxScan` 封装了索引节点的遍历功能，支持从叶节点的下界开始扫描至上界。
- `IxScan` 返回的每个元组对应一个 `RID`，指向表文件中的具体记录。

4. 条件过滤

由于索引范围可能较宽，实际扫描时需要对结果进行条件过滤：

- 逐步调用 `scan_->Next()` 获取下一个元组。
- 判断当前元组是否满足查询条件（通过 `predicate()`）。
- 跳过不满足条件的记录，继续扫描。

### 3.3.3 设计特点

- **灵活的条件解析**：支持单列和多列索引的条件组合。
- **高效的范围扫描**：通过 B+ 树的边界定位功能快速缩小扫描范围。

----

## 3.4 投影算子

### 3.4.1 Projection 的功能

`ProjectionExecutor` 实现了投影操作，即对查询结果进行字段选择的功能。其主要功能包括：

- 根据用户指定的字段列表（`sel_cols`），从输入元组中提取相应的字段。
- 支持字段重命名与聚合操作，如 `MAX`、`MIN`、`COUNT` 和 `SUM` 等。
- 返回投影后的结果，每次执行 `Next()` 时返回一个新的元组。

### 3.4.2 设计思路

1. 投影初始化

`ProjectionExecutor` 的构造函数初始化了投影操作所需的各项信息：

- **选择字段的解析**：根据输入的字段列表（`sel_cols`），计算并保存每个字段的偏移量、名称及其存储大小。
- **Schema 构造**：通过 `schema_` 构造新的记录模式（Schema），以便后续从输入元组中提取投影字段。
- **字段偏移计算**：为每个投影字段分配相应的存储偏移，确保按正确顺序存储投影结果。

2. 记录投影

投影过程通过 `projectRecord()` 方法完成，主要步骤如下：

- **元组获取**：从父节点（`prev_`）获取当前记录（元组）。
- **投影操作**：使用 `KeyFromTuple()` 将输入元组映射到新的记录中，选取用户指定的字段并按指定顺序返回。

3. 投影迭代

`beginTuple()` 和 `nextTuple()` 分别用于初始化投影操作和获取下一个符合条件的元组：

- **初始化**：调用 `prev_->beginTuple()` 初始化父节点的扫描，并获取第一条投影记录。
- **迭代**：每次调用 `nextTuple()` 时，从父节点获取下一条记录，并执行投影操作，直到遍历完所有记录。

### 3.4.3 设计特点

1. **灵活的字段选择**
   - 投影操作支持用户自定义的字段选择，能够灵活选择所需字段，并根据需求支持字段重命名。
   - 支持聚合操作，能够在投影阶段计算如最大值、最小值、计数、总和等统计值。
2. **高效的字段映射**
   - 使用 `KeyFromTuple()` 方法将父节点的元组映射到投影记录中，高效地从输入元组中提取指定的字段。
   - 通过 `sel_ids_` 保存投影字段在输入元组中的位置，以便在投影时快速访问相应的字段值。
3. **扩展性**
   - 设计上支持进一步扩展，可以轻松添加更多的字段选择与聚合操作。

----

## 3.5 嵌套循环连接

### 3.5.1 嵌套循环连接（Nested Loop Join）的功能

`NestedLoopJoinExecutor` 实现了数据库中的 **嵌套循环连接（Nested Loop Join）** 操作，它通过枚举左表（left table）和右表（right table）中的每一条记录，查找符合条件的记录对，最终返回连接后的结果。其主要功能包括：

- 遍历两个表中的每一条记录并进行比较，满足连接条件的记录对将被合并。
- 支持多条件的连接操作，并且可以处理左右表的不同连接条件（例如 `=`、`!=`、`<`、`>` 等）。
- 支持排序连接，当连接条件涉及到排序时，使用合适的排序方式优化查询。

### 3.5.2 设计思路

1. 初始化

`NestedLoopJoinExecutor` 的构造函数初始化了连接操作所需的各种参数：

- **左表和右表的初始化**：通过传入两个 `AbstractExecutor`（分别代表左表和右表），并从中获取表的名称、记录的长度（`left_len_` 和 `right_len_`）以及表的字段（`schema_`）。
- **连接条件的解析**：在连接条件（`fed_conds_`）中，主要处理等号连接条件（`OP_EQ`），并确定左右表中参与连接的列。若条件满足，记录连接列的元数据（`left_sel_colu_` 和 `right_sel_colu_`）。在需要排序的情况下，构建 `MergeSorter` 来处理左表的排序。
- **记录缓冲区**：为避免每次都访问底层数据，`left_buffer_` 和 `right_buffer_` 缓存了左表和右表的所有记录。

2. 嵌套循环连接的执行过程

连接过程由以下几个步骤组成：

- **beginTuple()**：在此方法中，左表和右表的所有记录会被加载到缓冲区（`left_buffer_` 和 `right_buffer_`）。接着，初始化连接的索引（`left_idx_` 和 `right_idx_`）。然后调用 `iterate_helper()` 方法开始遍历并尝试寻找符合连接条件的记录对。
- **nextTuple()**：用于获取下一对符合条件的连接记录。如果左表的记录被遍历完，`left_idx_` 会被重置为0并移动到右表的下一条记录，直到所有记录都被检查过。
- **iterate_helper()**：核心的迭代逻辑，负责遍历左表和右表的记录，并根据连接条件判断是否符合连接规则。若找到符合条件的记录，返回连接后的记录。
- **sorted_iterate_helper()**：在排序连接模式下使用，负责基于连接条件中的列值进行排序并逐步检查左右表的记录是否匹配。

3. 连接结果的合并

当找到符合条件的记录对时，`concat_records()` 会将左表和右表的记录合并为一个新的元组（`Tuple`）。合并后的记录被返回作为连接的结果。

### 3.5.3 设计特点

1. **嵌套循环连接实现**
   - 通过遍历左表和右表的每一条记录，并在符合连接条件时返回连接结果。对于每一对候选记录，都执行连接条件的判断，保证连接的正确性。
2. **支持复杂的连接条件**
   - `predicate()` 方法支持多种类型的连接条件，如等值连接（`OP_EQ`）、不等连接（`OP_NE`）、大小关系（`OP_LT`、`OP_GT` 等）。该方法通过比较左表和右表的列值来判断连接条件是否成立。
3. **排序优化**
   - 在处理涉及排序的连接条件时，`sorted_iterate_helper()` 方法能够对左表的记录进行排序优化，确保在匹配条件时能够提高性能。该选项可以自定义。
4. **高效的内存管理**
   - 使用缓冲区（`left_buffer_` 和 `right_buffer_`）缓存所有记录，避免每次都访问底层存储。通过合理的内存管理（如 `buffer_record_count`、`block_size`）确保连接操作在内存消耗方面的高效性。

### 3.5.4 连接条件的处理

`NestedLoopJoinExecutor` 处理连接条件的方式非常灵活，支持基于表中的列进行连接，并支持列与常数之间的比较。`predicate()` 方法中使用了各种比较运算符（如 `OP_EQ`、`OP_NE` 等）来实现条件判断。当连接条件中涉及表列时，系统会根据列的元数据提取对应的值进行比较；当涉及常数时，常数值直接与表列中的值进行比较。

---

## 3.6 归并连接

`MergeJoinExecutor` 是一个高效的执行器，利用 **Merge Join** 算法进行表的连接操作。它通过选择是否使用索引来优化执行路径，使用排序器对数据进行排序并高效地完成连接。它通过合理设计缓冲区、排序器和迭代器，使得在处理大量数据时能够高效地执行连接操作。

这种执行器设计不仅可以处理大规模的数据集，还能根据实际的查询优化策略，动态选择是否使用索引，确保数据库查询的性能和响应速度。

### 3.6.1 结构与功能

`MergeJoinExecutor` 是一个用于执行 **Merge Join** 算法的类，该算法通常用于两个有序集合的连接。`MergeJoinExecutor` 的核心思想是通过对两个输入数据集进行排序，然后按照指定的条件合并它们的记录。这个类是数据库引擎中的执行计划一部分，负责从查询中获取连接操作的执行步骤。

1. 构造函数 (MergeJoinExecutor)

构造函数接收四个参数：

a. `left` 和 `right`：分别是左表和右表的执行器，它们将提供需要连接的记录。
b. `conds`：包含连接条件的条件列表，通常会包括相等条件（`OP_EQ`），即基于某列的值进行连接。
c. `use_index`：一个布尔值，指示是否在连接操作中使用索引。如果为 `true`，则会通过索引加速查找。

构造过程中，`MergeJoinExecutor` 初始化了一些字段，如连接条件、左表和右表的模式（`Schema`）以及连接后结果的长度（`len_`）。接下来，它会根据连接条件确定要连接的列（即通过 `lhs_col` 和 `rhs_col` 确定）。同时，根据是否使用索引的选择，初始化排序器。

2. 核心方法

a. **`beginTuple()`**：
   - 初始化连接操作之前，检查是否使用索引。如果使用索引，首先将左表和右表的记录加载到缓冲区中。如果不使用索引，则需要先对左表和右表的记录进行排序，然后初始化排序器。
   - 调用 `nextTuple()` 启动第一次记录提取。
b. **`nextTuple()`**：
   - 判断是否使用索引。如果使用索引，调用 `index_iterate_helper()` 进行索引的连接。如果没有索引，则通过 `iterate_helper()` 进行标准的迭代连接。
   - 在连接的过程中，当找到了匹配的记录后，会通过 `concat_records()` 将匹配的记录合并成一个新的记录。
c. **`iterate_helper()`**：
   - 这是一个标准的合并连接的实现。通过排序后的数据流进行左右表记录的迭代，依次比较左表和右表的连接列的值：
     - 如果值相等，则继续合并记录。
     - 如果左表的值小于右表的值，则移动左表指针。
     - 如果右表的值小于左表的值，则移动右表指针。
   - 该过程重复进行，直到找到了匹配的记录或两个表中的一方迭代结束。
d. **`index_iterate_helper()`**：
   - 这是使用索引优化后的迭代方法，针对左右表的记录进行缓冲区中的迭代，通过索引加速查找过程。
e. **`concat_records()`**：
   - 在左右表记录匹配时，调用此方法将左表和右表的记录合并成一个新的记录。返回的是 `Tuple` 类型对象。
f. **`predicate()`**：
   - 判断当前左右表记录是否符合给定的连接条件。通常是基于列值进行比较（如相等、大小等）。

### 3.6.2 设计思路

执行流程如下：数据从两个输入表（左表和右表）传入，通过缓冲区和排序器处理，然后通过迭代器进行访问，最终返回连接后的结果。具体操作过程如下：

- 通过排序器对左表和右表的记录进行排序。
- 在迭代过程中，根据连接条件（如 `lhs_v == rhs_v`）比较左右表的记录，匹配时将结果记录合并输出。
- 每次找到一组匹配的记录后，调用 `concat_records()` 方法将左右记录合并。

### 3.6.3 优化与索引使用

`MergeJoinExecutor` 的一个关键优化是可以选择是否使用索引来加速连接操作。当 `use_index_` 设置为 `true` 时，执行器会在连接操作过程中通过索引加速记录的查找，从而减少不必要的迭代操作。当 `use_index_` 设置为 `false` 时，执行器会使用标准的 **Merge Sort** 算法对数据进行排序。

- **Merge Sort**：在数据量较大的情况下，排序能显著提高连接操作的效率。通过 `MergeSorter`，`MergeJoinExecutor` 将会对左右表进行排序并构建合并树，然后高效地进行合并操作。

-------

## 3.7 哈希连接

### 3.7.1 概述

哈希连接是关系数据库系统中的连接算法之一，特别适用于大规模数据集的等值连接操作。`HashJoinExecutor` 是本系统中实现哈希连接逻辑的核心模块，负责高效地将两个数据源（左输入和右输入）基于指定的连接条件进行匹配和组合。通过利用哈希表结构，哈希连接能够显著减少连接操作的计算复杂度，提升查询性能。

### 3.7.2 哈希连接执行器（HashJoinExecutor）

1. HashJoinExecutor 的功能

`HashJoinExecutor` 的主要功能包括：

- **哈希表构建**：从左输入数据源中提取连接键，并基于这些键构建哈希表。
- **哈希表探测**：遍历右输入数据源，通过连接键在哈希表中查找匹配的元组。
- **条件过滤**：确保连接结果满足所有指定的连接条件。
- **结果生成**：将匹配的左右元组合并为一个新的元组，作为连接结果输出。

2. 设计思路

`HashJoinExecutor` 的设计主要包括以下几个关键步骤：

a 哈希表构建

- **选择合适的输入**：通常选择较小的数据源作为哈希表的构建输入（左输入），以减少内存消耗和提高缓存命中率。
- **提取连接键**：根据连接条件，从左输入的每个元组中提取用于连接的字段值，形成连接键。
- **构建哈希表**：将提取的连接键作为哈希表的键（`HashJoinKey`），对应的元组作为值，存储在 `std::unordered_multimap` 结构中，以支持键值的多重匹配。

b 哈希表探测

- **遍历右输入**：逐元组遍历右输入数据源。
- **提取连接键**：从每个右输入元组中提取连接键，与哈希表中的键进行匹配。
- **查找匹配**：在哈希表中查找与右输入元组连接键相匹配的所有左输入元组。
- **生成连接结果**：对于每一个匹配的左输入元组，将其与当前右输入元组合并，生成连接结果元组。

c 条件过滤

- **多条件支持**：支持等值连接。
- **谓词评估**：在生成连接结果前，对每一对候选元组应用所有连接条件，确保只有满足所有条件的元组对被输出。

### 3.7.3 详细设计

1. 构建哈希表

在连接操作的初始阶段，`HashJoinExecutor` 从左输入数据源中提取连接键，并基于这些键构建哈希表。具体步骤包括：

a. **初始化左输入**：调用左输入执行器的 `beginTuple()` 方法，开始元组的迭代。
b. **迭代左输入元组**：逐元组调用左输入的 `Next()` 方法，获取每一个元组。
c. **提取连接键**：根据连接条件，从每个左输入元组中提取指定的连接字段，形成连接键。
d. **插入哈希表**：将连接键和对应的元组插入到哈希表中，支持键的多重匹配。

2. 探测哈希表

在哈希表构建完成后，`HashJoinExecutor` 开始遍历右输入数据源，并通过连接键在哈希表中查找匹配的左输入元组。具体步骤包括：

a. **初始化右输入**：调用右输入执行器的 `beginTuple()` 方法，开始元组的迭代。
b. **迭代右输入元组**：逐元组调用右输入的 `Next()` 方法，获取每一个元组。
c. **提取连接键**：根据连接条件，从每个右输入元组中提取指定的连接字段，形成连接键。
d. **查找匹配元组**：在哈希表中查找所有与当前连接键匹配的左输入元组。
e. **生成连接结果**：将匹配的左右元组合并，生成新的连接结果元组，并通过 `Next()` 接口输出。

3. 条件过滤

在生成连接结果之前，`HashJoinExecutor` 对每一对候选元组应用所有连接条件，确保结果的准确性。具体步骤包括：

1. **遍历连接条件**：对于每一个连接条件，提取左右元组中对应的字段值。
2. **评估条件**：根据条件类型（如等值、不等、范围等），比较左右字段值，判断是否满足条件。
3. **结果验证**：只有当所有条件均被满足时，才将元组对作为有效的连接结果输出。

## 3.8 归并排序器

### 3.8.1 概述

`MergeSorter` 类是 `easydb` 数据库系统中的一个关键组件，负责实现排序操作，用于归并连接（merge join）和嵌套循环连接（nested loop join）以及后续order by子句的过程中。该类实现了一种高效的多路归并排序算法，旨在处理无法完全装入内存的大型数据集。它将数据拆分成较小的块，对每个块进行排序，然后执行最终的归并操作。

### 3.8.2 类设计

`MergeSorter` 类负责基于指定的列（键）对元组进行排序。它维护一个内存中的缓冲区来存储数据的一部分，当缓冲区满时，将已排序的数据写入临时文件。所有块排序完成后，它通过使用“败者树”结构来合并这些已排序的块，该结构能够高效地选择多路归并中的最小值或最大值。核心方法如下：

1.  **构造函数:** 构造函数使用指定的排序列、元组模式列、元组长度和排序顺序（升序或降序）初始化排序器。它还初始化了缓冲区、文件列表和其他必要的变量。
2.  **writeBuffer(Tuple current_tuple):** 该方法将一个元组添加到内存缓冲区中。当缓冲区已满时，进行排序，并将已排序的数据写入临时文件，然后清空缓冲区以准备接收更多的元组。
3.  **clearBuffer():** 清空当前缓冲区，排序元组后将其写入临时文件，确保所有数据在合并阶段前都已写入磁盘。
4.  **initializeMergeListAndConstructTree():** 初始化归并列表，通过读取磁盘上排序的块并将它们载入内存，构建败者树。败者树用于高效地归并已排序的块。
5.  **IsEnd():** 返回 `true` 表示所有记录已输出，归并过程已完成。它检查所有块是否已处理完毕，或者是否没有更多的记录需要归并。
6.  **getOneRecord():** 该方法从归并过程中获取下一条记录。它利用败者树来确定从哪个块获取记录，并推进该块的文件指针。当一个块被耗尽时，它会被标记为 `NULL`。
7.  **createLoserTree():** 构建败者树，败者树是一个二叉树，用于确定从哪些已排序块中获取下一个记录。树的每个叶节点对应一个块，树通过调整来确保根节点始终保存最小或最大值。
8.  **adjust(int s):** 该方法调整败者树，以反映每次从块中取出记录时发生的变化。对应于已获取记录的块的节点会更新为新的“赢家”，确保根节点始终保存最小或最大值。

### 3.8.3 归并排序过程

1. **初始排序：** `writeBuffer()` 方法确保数据在内存中缓冲，直到缓冲区满为止。当缓冲区满时，缓冲区中的数据会被排序并写入临时文件。这是外部排序阶段，在此阶段，数据被拆分成适合内存的较小块进行处理。
2. **归并阶段：** 所有数据被排序成块后，`initializeMergeListAndConstructTree()` 方法准备归并操作。块被读取到内存中，并构建败者树。`getOneRecord()` 方法根据当前最小或最大键值，决定从哪个块中获取下一条记录。
3. **高效的归并：** `adjust()` 方法确保每次从块中取出记录后，败者树能正确更新，以便始终从正确的块中获取下一条记录。

### 3.8.4 性能考虑

- **内存效率：** 通过使用内存缓冲区并在缓冲区满时将排序后的数据写入磁盘，`MergeSorter` 类能够处理无法完全装入内存的大型数据集。`BUFFER_MAX_SIZE` 和 `BUFFER_MAX_RECORD_COUNT` 参数可以根据不同的环境优化内存使用。
- **I/O效率：** 该类通过先在内存中排序数据然后写入磁盘，并采用多路归并技术，最大限度地减少了 I/O 操作的次数。这比简单的两路归并方法减少了读取和写入的次数。
- **败者树：** 败者树的使用优化了归并过程，减少了查找下一个最小或最大值的时间复杂度。即使在归并多个已排序块时，它也能确保归并阶段的高效性。

-----

## 3.9 查询计划示例

我们实现了实验要求的所有查询类型。本小节通过介绍各类查询的算子组织方式来阐释我们如何通过上述算子实现了实验要求 的所有查询。由于选择操作和投影操作为SQL查询中必要的操作，我们不再专门介绍。

- 嵌套循环连接 
  
  - `ProjectionExecutor` <-`NestedLoopJoinExecutor`<-`SeqScanExecutor`

- 基于排序的等值连接  
  
  - `ProjectionExecutor` <-`MergeJoinExecutor`<-`SeqScanExecutor`

- 基于散列的等值连接  
  
  - `ProjectionExecutor` <-`HashJoinExecutor`<-`SeqScanExecutor`

- 基于索引的连接 
  
  - `ProjectionExecutor` <-`NestedLoopJoinExecutor`<-`IndexScanExecutor`

对于不同连接策略的选择，我们自定义了以下字段进行索引策略选择，默认情况下，默认嵌套循环连接>排序连接>HashJoin。

```
SET enable_nestloop = false/true;
SET enable_sortmerge = false/true;
SET enable_hashjoin = false/true;
```

# 4 使用手册

## 4.1 编译

```shell
# 先进入到项目目录
cd /path/to/easydb

# 新建build目录并进入
mkdir build
cd build

# 使用cmake编译项目
cmake ..
make -j
```

## 4.2 运行

```shell
# 进入到build/bin/目录下
cd build/bin/

# 启动服务端
./easydb_server -d test.db -p 8765

# 启动客户端
./easydb_client -p 8765

# 在客户段中输入help;可以查看帮助信息
# 在客户端中执行SQL语句即可查看到执行的结果，如：
SELECT * FROM supplier WHERE S_NAME = 'Supplier#000000003';
```

![界面展示](images/1.png)

# 5 测试方案与结果

## 5.1 测试设计与实现

我们使用SQL语句进行测试，为了能够更方便地进行测试，我们编写了一个测试脚本，该脚本可以自动启动服务端和和客户端，导入测试数据，并执行SQL语句，然后输出结果。该脚本放在根目录下的test/spj/spj_test.sh。

### 5.1.1 服务端的启动和关闭

我们的数据库系统是C/S架构的，因此每次在执行SQL语句之前，需要将服务端启动。这里我们使用bash脚本进行启动，将stdout和stderr都重定向到日志文件中，以便后续查看。我们的服务端是在后台运行的，因此需要等待一段时间，以便服务端启动完成。这里我们使用sleep函数等待一段时间，然后检查服务端是否已经启动完成。

```shell
# 首先启动server
print_green "启动server"
$SERVER_PATH -d $DB_PATH -p $SERVE_PORT > $SERVER_LOG_PATH 2>&1  &
sleep 10
```

在我们完成测试的所有操作之后，运行在后台的服务端也需要关闭，这里我们使用kill命令关闭服务端进程。

```shell
clean_up(){
    # print_red "执行清理操作"
    ps -aux | grep easydb | grep $(whoami) | awk '{print $2}' | xargs kill -9 > /dev/null 2>&1
}
# 退出时调用clean_up函数关闭Server进程
trap clean_up EXIT;
```

### 5.1.2 SQL语句的执行

为了能够优雅地在脚本中执行SQL语句，我们将执行SQL语句的命令封装成了一个函数，该函数接受一个参数，即SQL语句。然后我们会启动一个客户端连接到服务端，执行了该SQL语句后关闭该客户端。具体来说，我们使用了execute函数实现该功能。我们将语句从管道中传入到客户端的stdin中，执行完毕后，客户端会自动退出。

```shell
execute(){
    print_blue "执行命令: $1"
    echo "$1; exit;" | $CLIENT_PATH -p $SERVE_PORT
}
```

### 5.1.3 测试数据的导入

我们的数据库实现了load命令，该命令能够从文件中读取并导入数据到数据库中。所以，我们可以使用以下的shell命令将测试数据导入到数据库中。

```shell
execute "load $DATA_SUPPLIER_PATH into supplier;"
```

### 5.1.4 测试点设置

为了能够更加全面地测试我们的数据库系统，我们需要设置一些测试点。

1. Select相关测试

这部分主要是测试我们select语句的执行情况，包括单点查询和范围查询。我们分别对int，float，varchar三种类型进行选择查询。主要有以下几个测试点：

```shell
print_green "==> int上进行条件选择"
execute "SELECT * FROM supplier where S_SUPPKEY = 10;"
execute "SELECT * FROM supplier where S_SUPPKEY > 10 AND S_SUPPKEY < 20;"

print_green "==> float上进行条件选择"
execute "SELECT * FROM supplier where S_ACCTBAL < 3000.0;"
execute "SELECT * FROM supplier where S_ACCTBAL > 1000.5 AND S_SUPPKEY < 2000.1;"

print_green "==> varchar上进行条件选择"
execute "SELECT * FROM supplier where S_NAME = 'Supplier#000000015';"
execute "SELECT * FROM supplier where S_SUPPKEY > 10 AND S_SUPPKEY < 20 AND S_NAME != 'Supplier#000000015';"
```

2. Projection相关测试

这部分主要是测试我们投影功能的实现情况，包括多列投影和*。主要有以下几个测试点：

```shell
print_green "=> select 至少三种不同数据(int, varchar, float)"
execute "SELECT S_SUPPKEY, S_NAME, C_ACCTBAL FROM supplier where S_SUPPKEY > 10 AND S_SUPPKEY < 20;"
print_green "=> select *"
execute "SELECT * FROM supplier where S_SUPPKEY > 10 AND S_SUPPKEY < 20;"
```

3. Join相关测试

这部分主要是测试我们join功能的实现情况，包括了NestLoop Join，Sort Merge Join和Hash Join以及基于索引的连接。针对以上连接，我们分别进行了以下测试：

a. 单条件等值连接：主要测试了int，char，varchar上的单条件等值连接。

```shell
print_green "==> int上进行单条件等值连接"
execute "SELECT * FROM supplier, nation where S_SUPPKEY < 10 AND S_NATIONKEY = N_NATIONKEY;"

print_green "==> char上进行单条件等值连接"
execute "SELECT * FROM supplier, customer where S_SUPPKEY < 100 AND C_CUSTKEY < 100 AND S_PHONE = C_PHONE;"

print_green "==> varchar上进行单条件等值连接"
execute "SELECT * FROM supplier, customer where S_SUPPKEY < 100 AND C_CUSTKEY < 100 AND S_NAME = C_NAME;"
```

b. 单条件不等值连接：主要测试了char上的单条件不等值连接

```shell
execute "SELECT * FROM supplier, customer where S_SUPPKEY < 100 AND C_CUSTKEY < 100 AND S_PHONE != C_PHONE;"
```

c. 多条件连接：主要测试了int, varchar上的多条件连接。

```shell
print_green "==> int, varchar上进行多条件连接"
execute "SELECT * FROM supplier, customer where S_SUPPKEY < 10 AND C_CUSTKEY < 10 AND S_PHONE != C_PHONE AND S_SUPPKEY != C_CUSTKEY;"
```

d. 三表连接：

```shell
print_green "=> 三表连接"
execute "SELECT * FROM supplier, customer, nation where S_SUPPKEY < 10 AND C_CUSTKEY < 10 AND S_NATIONKEY = N_NATIONKEY AND C_NATIONKEY = N_NATIONKEY;"
```

e. 两表卡氏积连接：

```shell
print_green "=> 两表卡氏积连接"
execute "SELECT * FROM supplier, customer where S_SUPPKEY < 10 AND C_CUSTKEY < 10;"
```

## 5.2 结果展示

### 5.2.1 初始化数据库

1. 服务端启动

![服务端启动](./images/2.png)

2. 表格创建

![表格创建](./images/3.png)

3. 数据导入

![数据导入](./images/4.png)

4. 索引创建

![索引创建](./images/5.png)

### 5.2.2 Select测试

1. int类型

![int类型 select测试1](./images/6.png)

![int类型 select测试2](./images/7.png)

2. float类型

![float类型 select测试1](./images/8.png)

![float类型 select测试2](./images/9.png)

3. varchar类型

![varchar类型 select测试1](./images/10.png)

![varchar类型 select测试2](./images/11.png)

### 5.2.3 Projection测试

![Projection测试1](./images/19.png)

![Projection测试2](./images/20.png)

### 5.2.4 Join测试

Join测试时，虽然我们使用的方式不一样，但是是结果是一样的，所以只展示NestLoop的结果。

1. 单条件等值连接

![int类型 单条件等值连接](./images/12.png)

![char类型 单条件等值连接](./images/13.png)

![varchar类型 单条件等值连接](./images/14.png)

2. 单条件不等值连接

![char类型 单条件不等值连接](./images/15.png)

3. 多条件连接

![int,varchar类型 多条件连接](./images/16.png)

4. 三表连接

![三表连接](./images/17.png)

5. 两表卡氏积连接

![两表卡氏积连接](./images/18.png)

# 6 实验总结

在本次实验中，我们成功实现了数据库查询处理器的关键组件，包括多种扫描算子、连接算子和投影操作。通过深入理解和应用数据库系统的迭代器模型，我们构建了一个高效的查询执行框架，能够处理包括顺序扫描、索引扫描、多种连接操作和投影操作在内的复杂查询。

## 6.1 实验成果

1. **查询处理器的构建**：我们构建了一个功能齐全的查询处理器，支持多种算子，包括数据操作算子、扫描算子和连接算子。这为数据库系统提供了强大的数据处理能力。

2. **迭代器模型的应用**：通过采用迭代器模型，我们实现了查询操作的逐元组处理，提高了查询效率和系统的整体性能。

3. **多种连接操作的实现**：我们实现了嵌套循环连接、基于排序的等值连接、基于散列的等值连接和基于索引的连接等多种连接操作，这些操作是数据库查询中的核心功能。

4. **投影操作的优化**：我们实现了投影操作，允许用户从查询结果中选择特定的字段，支持字段重命名和聚合操作，提高了查询的灵活性。

5. **测试方案与结果**：我们设计了全面的测试方案，包括服务端的启动和关闭、SQL语句的执行、测试数据的导入和多个测试点的设置。测试结果表明，我们的系统能够正确执行各种查询操作，并返回预期的结果。

## 6.2 遇到的问题与解决方案

1. **性能优化**：在实现过程中，我们遇到了性能瓶颈，特别是在处理大规模数据集时。通过引入多路归并排序算法和优化内存管理，我们显著提高了系统的性能。

2. **连接操作的复杂性**：连接操作的实现相对复杂，尤其是在处理多条件连接时。我们通过详细设计连接操作的逻辑和条件过滤机制，成功解决了这一问题。

3. **测试自动化**：为了提高测试的效率和准确性，我们编写了自动化测试脚本，减少了人工干预，确保了测试的一致性和可重复性。

## 6.3 实验心得

通过本次实验，我们深入理解了数据库查询处理器的工作原理和实现细节。我们学会了如何设计和实现高效的查询执行计划，以及如何通过测试来验证系统的正确性和性能。此外，我们也体会到了团队合作的重要性，每个成员都在实验中扮演了关键角色，共同推动了项目的进展。

## 6.4 未来工作

尽管我们已经实现了实验的基本要求，但仍有许多工作可以进一步探索和完善。例如，我们可以进一步优化查询执行器的性能，增加对更多类型查询的支持，以及提高系统的可扩展性和容错能力。此外，我们还可以探索如何将机器学习技术应用于查询优化，以进一步提高数据库系统的性能。